
-- 사용자 계정 보기 (=Database) 리스트 보기 

select * from dba_users;


-- 사용자 계정 lcok 해지 
--alter user [유저네임] account unlock; 


select name from v$database;

--사용자 계정 만들기 
create user javadb IDENTIFIED by javadb;



create table goodsinfo(
    code char(5) not null primary key, --기본키를 code로 설정 null 이면 안되고 char형태로 
    name VARCHAR2(30) not null,           --30개의 문자를 쓸수 있는 컬럼  null 이면 안됨 
    price NUMBER(8) not null                -- price 데이터 number 형식으로 8자 null 이면 안됨 
); 


--ch03 sql 기본 

select * from TAB; --TABLE 보기

desc dept;--describe


select empno, ename, SAL*12 as yearsal from emp;

--null값을 없애는 법  ->comm 값이 null 이 아닌 0으로 표시하기 nvl(해당속성,0)

select empno, ename, nvl(comm,0) , SAL*12 as 연봉 from emp;

-- 3가지 값이 하나로 표현  || 
select ename || ' is a' || job from emp;

-- 이건 합쳐지지 않고 구분되서 결과값 나옴 
select ename ,' is a' , job from emp;


--중복 제거  distinct
select DISTINCT deptno from emp;

select DISTINCT job from emp;

--문자열 데이터 조회 -데이터의 값은 대소문자 로 비교 
select empno, ename, sal from emp where ename='FORD';


--  1982/01/01 이후에 있는 사원이 이름 출력하기 

select ename, hiredate from emp where hiredate >= '1982/01/01';

--논리 연산자 and
select * from emp where deptno=10 and job='MANAGER';

select * from emp where not deptno=10;

select * from emp where deptno <> 10;

select * from emp where deptno !=10;


-- 문제 2000~3000 사이의 급여를 받는 사원 명단 

select ename,sal from emp where sal >2000 and sal <3000;


-- in == or와 같다  즉 in 안에 있는 값들을 출력 
select * from emp where comm not in (300,500,1400);


--LIKE (%)  LIKE(_)   -> ename like'f%'  _는 한문자열을 의미
select * from emp where ename='F';
select * from emp where ename LIKE'F%' ;

select * from emp where  ename like'%A%'; -- A가 포함된 데이터 뽑기 LIKE%찾는값%

select * from emp where  ename not like'%A%';


select * from emp where  ename like'_A%'; -- 문자 하나 있고 두번쨰가  A인경우 
select * from emp where  ename like'%__A%'; -- 세번째 자리에 A가 있는경우 

select * from emp where comm is not null;

select * from emp  order by comm desc, empno desc; -- desc 오름 차순 


--상관이 없는 manager가 없는 사원  -> NULL 값 찾을 때는 = 이 아니라 IS 로 해야한다 
select * from emp WHERE mgr IS NULL ;



select * from customer;
select * from orders;
-- 고객과 고객의 주문에 대한 데이터 모두 출력
select * from customer, orders where customer.custid = orders.orderid; -- 기본 조인 


--슈퍼키 기본키가 포함된집합 ->ex)(기본키 , a라는 속성) (기본키 a , b) ......
--데이터 베이스에서의 도메인은 범위를 의미한다.
--
create table orders (
orderid NUMBER(2) primary key,
custid NUMBER(2) REFERENCES Customer(custid),  -- REFEERECE 참조하여 CUSTOMER 테이블에 있는 ID 값을 사용 (즉,CUSTOMER이 있어야함)
bookid NUMBER(2) REFERENCES Book(bookid),
saleprice NUMBER(8),
orderdate DATE

);   

--2 . 집계 함수 


select deptno, round(sal,3) from emp; -- 단일행 함수 - 결과가 여러개

select sum(sal) from emp;

select ename,max(sal) from emp group by ename; -- group by로 묶어서 사용하면 단일행 함수 사용 가능 

select sum(sal), round(sal,-3) from emp group by sal; -- round -3이면 소수점 -3 즉 1000의 자리 만큼만  

select round(avg(sal),3), max(sal),min(sal) from emp;  

--* 을 했을경우에는 null 값 도 포함하여 개수를 파악 결과값 14, 4
select count(*), count(comm) from emp;

select count(job) from emp;

select  count(DISTINCT job) from emp; -- distinct 중복 제거  count 안에 해줘야 적용 

--가장 최근에 입사한 사원의 입사일과 가장 오래된 사원의 입사일 
select min(hiredate) as 오래된 , max(hiredate) as 가장최근 from emp;


-- 10번 부서 deptno 소속의 사원중에서 comm 을 받는 사원수는? 
select count(comm) from emp where deptno=30;



--3 . Group by  집계 함수와 컬럼 이름 단일행 함수 같이 사용 


select round(avg(sal),3), deptno as 부서 from emp group by deptno;


--소속 부서별 deptno  급여 총액과 평균 

select avg(sal),sum(sal), deptno from emp group by deptno;


--부서별 사원수와 커미션을 받는 사원수 

select count(*), count(comm) from emp group by deptno ;

select deptno as 부서, count(*), count(comm) from emp group by deptno ;


--having 절 

select avg(sal),sum(sal), deptno from emp group by deptno having avg(sal) >=2000;



--- 부서의 최소값과 최대값 구하기  급여 최대급여가 2900 이상인 부서만 출력 

select  min(sal), max(sal) from emp group by deptno having max(sal) >=2900;




-- self join
-- 이름이 smith인 사원의 manager 이름 ( 즉 smith 에서 manger mgr 값을 찾고 이름 찾기 )

select e.ename ||'의 매니저는'|| m.ename from emp e, emp m  where e.mgr=m.empno and  e.ename='SMITH';


--매니저가 KING인 사원의 이름과 직급 출력 
select e.ename , e.job from emp e, emp m  where e.mgr=m.empno and  m.ename='KING';


--outer join - 마당 데이터 
-- 주문하지 않는 고객 이름 
select customer.name from customer left outer join orders on orders.custid=customer.custid where orders.custid is null;



select  customer.name, orders.saleprice
from  customer, orders
where customer.custid=orders.custid(+);  -- (+) 이건 주문하지 않는 이라는 코드 right outer join 과 동일한 값 으로  나옴 
--where customer.custid(+)=orders.custid;  -- 왼쪽이면 left outer join 과 동일 

select  customer.name, orders.saleprice
from  customer, orders
where customer.custid=orders.custid;  

--사원이름이 scott 이 속해있는 부서명 
select dept.dname
from emp inner join dept
on emp.deptno=dept.deptno and emp.ename='SCOTT';

--using 사용하는 법 
select dept.dname
from emp inner join dept
using(deptno) where emp.ename='SCOTT';   -- join 시 depptno 는 같다는 당연하기 때문에 using으로 코드 단축 

--Natural join 
select dept.dname
from emp Natural join dept      -- using 마저도 생략 하려면 Natural join 
 where emp.ename='SCOTT';  


---outer join
--기존 join 에서 모든 레코드가 출력 될때 (+) 사용을 대신하여 ->left , right full 로 대신하여 사용 

select dept.dname
from emp Natural right join dept      -- using 마저도 생략 하려면 Natural join 
 where emp.ename='SCOTT';  
 
 --madang 데이터베이스
 select customer.name saleprice from customer NATURAL LEFT join orders;
 
 
 --SCOTT 계정
 --CH03 03 SUBQUERY(부속질의)
 select depno from emp where ename='SCOTT';
 select * from dept where deptno=20;
 -- 위에 있는 쿼리를 부속 질의 로 표현해보기
 select dname from dept 
 where deptno = (select deptno from emp where ename='SCOTT');
 
--DALLAS에서 근무하는 사원의 이름 부서번호 
select ename,deptno from emp where deptno = (select deptno from dept where loc='DALLAS');

-- 사원들이 받는 평균 급여 보다 더 많이 받는 사원의 이름 과 급여 ? 
SELECT ENAME, SAL FROM EMP  WHERE SAL > (SELECT AVG(SAL) FROM EMP);

-- 연봉 3000이상 받는 사원이 소속된 부서와 같은 부서에 근무하는 사원의 정보 출력 

SELECT ENAME,SAL,DEPTNO 
FROM emp
WHERE deptno=(SELECT DISTINCT DEPTNO FROM EMP  WHERE SAL>=3000);
-- deptno 에 두개의 값이 나와 오류 

SELECT ENAME,SAL,DEPTNO 
FROM emp
WHERE deptno in (SELECT DISTINCT DEPTNO FROM EMP  WHERE SAL>=3000);

-- 부서별로 급여를 가장 많이 받는 사원정보 

select ENAME,SAL,DEPTNO
FROM EMP 
WHERE SAL IN (SELECT DISTINCT MAX(SAL) FROM EMP GROUP BY deptno); 


--직급이 manger인 사람이 속한 부서의 부서번호 부서명 지역 

select * from dept
where deptno in (select deptno from emp where job='MANAGER');





-- any -최소값 /some 도 같은 말 
-- 부서번호가 30인  사원들의 급여중에서 가장 낮은값 보다 높은 급여를 받는 사원의 이름 급여 
select ename, sal from emp 
where sal > any (select sal from emp where deptno=30);


-- 영업사원의 최소 급여보다 급여를 많이 받는 사원들의 이름과 급여 출력  
select job, ename, sal 
from emp 
where sal > any (select sal from emp where job='SALESMAN');

--exists 
-- 메인 쿼리 의 비교 조건이 서브 쿼리의 결과중에서 만족하는 값이  하나라도 존재하면  참
-- 주문이 있는 고객의 이름과 주소 
--madang 계정 
select name, address
from customer c
where    exists (select * from orders o  where c.custid=o.custid);


--cho03-4 ddl 


create table emp01(
 empno number(4),
 ename varchar2(20),
 sal number(7)


); -- table 만들기


desc emp01;

-- sub 쿼리로 테이블 생성 
create table emp02 as select *  from emp;  -- 테이블 복사 


select * from emp02;

-- 원하는 컬럼으로 구성된 복제 테이블

create table emp03 as select empno,ename from emp;  

????
